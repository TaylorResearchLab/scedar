

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scedar.eda.slcs &mdash; scedar 0.0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="scedar 0.0.1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> scedar
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">scedar</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../scedar.html">scedar package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../scedar.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../scedar.cluster.html">scedar.cluster package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scedar.eda.html">scedar.eda package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../scedar.qc.html">scedar.qc package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../scedar.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scedar.html#module-scedar.utils">scedar.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scedar.html#module-scedar">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">scedar</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>scedar.eda.slcs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scedar.eda.slcs</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">ks_2samp</span>

<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">train_test_split</span>
<span class="kn">import</span> <span class="nn">sklearn.utils</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>

<span class="kn">import</span> <span class="nn">xgboost</span> <span class="k">as</span> <span class="nn">xgb</span>

<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">from</span> <span class="nn">scedar.eda.sdm</span> <span class="k">import</span> <span class="n">SampleDistanceMatrix</span>
<span class="kn">from</span> <span class="nn">scedar.eda.plot</span> <span class="k">import</span> <span class="n">swarm</span>
<span class="kn">from</span> <span class="nn">scedar.eda.plot</span> <span class="k">import</span> <span class="n">heatmap</span>
<span class="kn">from</span> <span class="nn">scedar.eda</span> <span class="k">import</span> <span class="n">mdl</span>
<span class="kn">from</span> <span class="nn">scedar.eda</span> <span class="k">import</span> <span class="n">mtype</span>
<span class="kn">from</span> <span class="nn">scedar</span> <span class="k">import</span> <span class="n">utils</span>


<div class="viewcode-block" id="SingleLabelClassifiedSamples"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples">[docs]</a><span class="k">class</span> <span class="nc">SingleLabelClassifiedSamples</span><span class="p">(</span><span class="n">SampleDistanceMatrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data structure of single label classified samples</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _x (2D number array): (n_samples, n_features) data matrix.</span>
<span class="sd">        _d (2D number array): (n_samples, n_samples) distance matrix.</span>
<span class="sd">        _labs (list of labels): list of labels in the same type, int or str.</span>
<span class="sd">        _fids (list of feature IDs): list of feature IDs in the same type,</span>
<span class="sd">            int or str.</span>
<span class="sd">        _sids (list of sample IDs): list of sample IDs in the same type,</span>
<span class="sd">            int or str.</span>
<span class="sd">        _metric (str): Distance metric.</span>

<span class="sd">    Note:</span>
<span class="sd">        If sort by labels, the samples will be reordered, so that samples from</span>
<span class="sd">        left to right are from one label to another.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sid, lab, fid, x</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">labs</span><span class="p">,</span> <span class="n">sids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># sids: sample IDs. String or int.</span>
        <span class="c1"># labs: sample classified labels. String or int.</span>
        <span class="c1"># x: (n_samples, n_features)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SingleLabelClassifiedSamples</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">sids</span><span class="o">=</span><span class="n">sids</span><span class="p">,</span> <span class="n">fids</span><span class="o">=</span><span class="n">fids</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>

        <span class="n">mtype</span><span class="o">.</span><span class="n">check_is_valid_labs</span><span class="p">(</span><span class="n">labs</span><span class="p">)</span>
        <span class="n">labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">labs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sids must have the same length as labs&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span> <span class="o">=</span> <span class="n">labs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_up_lab_rel_attrs</span><span class="p">()</span>
        <span class="c1"># keep a copy of original labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_labs</span> <span class="o">=</span> <span class="n">labs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xgb_lut</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_set_up_lab_rel_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up labels related attrs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_lab_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># {lab: array([sid0, ...]), ...}</span>
        <span class="n">sid_lut</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="p">:</span>
            <span class="n">sid_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span> <span class="o">==</span> <span class="n">ulab</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sid_lut</span> <span class="o">=</span> <span class="n">sid_lut</span>
        <span class="c1"># {sid1: lab1, ...}</span>
        <span class="n">lab_lut</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># sids only contain unique values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">lab_lut</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lab_lut</span> <span class="o">=</span> <span class="n">lab_lut</span>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.sort_by_labels"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.sort_by_labels">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy with sorted sample indices by labels and distances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labs</span><span class="p">)</span>
        <span class="c1"># slcs is empty</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind_x</span><span class="p">()</span>
        <span class="n">uniq_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">s_ind_lut</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">ulab</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">ulab</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="n">uniq_labs</span><span class="p">])</span>
        <span class="c1"># sort within each label</span>
        <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="n">uniq_labs</span><span class="p">:</span>
            <span class="c1"># get sample indices of that class</span>
            <span class="n">s_inds</span> <span class="o">=</span> <span class="n">s_ind_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span>
            <span class="c1"># sort that class by distance to the first sample</span>
            <span class="c1"># get a list of distances to the frist sample</span>
            <span class="n">s_dist_to_s0_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">s_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s_inds</span><span class="p">))]</span>
            <span class="c1"># sort indices by distances</span>
            <span class="n">sorted_s_inds</span> <span class="o">=</span> <span class="n">s_inds</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">s_dist_to_s0_list</span><span class="p">,</span>
                                              <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
            <span class="c1"># update lut</span>
            <span class="n">s_ind_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_s_inds</span>
        <span class="c1"># sort classes by distances of first samples</span>
        <span class="c1"># frist sample indices</span>
        <span class="n">lab_fs_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_ind_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="n">uniq_labs</span><span class="p">]</span>
        <span class="c1"># distance of first samples to the first class first sample</span>
        <span class="n">lab_fs_dist_to_fc_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">lab_fs_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lab_fs_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lab_fs_inds</span><span class="p">))]</span>
        <span class="n">sorted_ulabs</span> <span class="o">=</span> <span class="n">uniq_labs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lab_fs_dist_to_fc_list</span><span class="p">,</span>
                                            <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)]</span>
        <span class="n">sorted_s_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">s_ind_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span>
                                        <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="n">sorted_ulabs</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind_x</span><span class="p">(</span><span class="n">sorted_s_inds</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.filter_min_class_n"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.filter_min_class_n">[docs]</a>    <span class="k">def</span> <span class="nf">filter_min_class_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_class_n</span><span class="p">):</span>
        <span class="n">uniq_lab_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nf_sid_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">,</span> <span class="p">(</span><span class="n">uniq_lab_cnts</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="n">uniq_lab_cnts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_class_n</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind_x</span><span class="p">(</span><span class="n">nf_sid_ind</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.labs_to_sids"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.labs_to_sids">[docs]</a>    <span class="k">def</span> <span class="nf">labs_to_sids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sid_lut</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">labs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.sids_to_labs"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.sids_to_labs">[docs]</a>    <span class="k">def</span> <span class="nf">sids_to_labs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sids</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_lab_lut</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sids</span><span class="p">])</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.ind_x"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.ind_x">[docs]</a>    <span class="k">def</span> <span class="nf">ind_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_s_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">selected_f_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subset samples by (sample IDs, feature IDs).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        selected_s_inds: int array</span>
<span class="sd">            Index array of selected samples. If is None, select all.</span>
<span class="sd">        selected_f_inds: int array</span>
<span class="sd">            Index array of selected features. If is None, select all.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset: SingleLabelClassifiedSamples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">selected_s_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_s_inds</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">selected_f_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_f_inds</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SingleLabelClassifiedSamples</span><span class="p">(</span>
                   <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">selected_s_inds</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">selected_f_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                   <span class="n">labs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">[</span><span class="n">selected_s_inds</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">selected_s_inds</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">selected_s_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                   <span class="n">sids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="p">[</span><span class="n">selected_s_inds</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="n">fids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fids</span><span class="p">[</span><span class="n">selected_f_inds</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nprocs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.merge_labels"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.merge_labels">[docs]</a>    <span class="k">def</span> <span class="nf">merge_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig_labs_to_merge</span><span class="p">,</span> <span class="n">new_lab</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge selected labels into a new label</span>

<span class="sd">        Args:</span>
<span class="sd">            orig_labs_to_merge (list of unique labels): original labels to be</span>
<span class="sd">                merged into a new label</span>
<span class="sd">            new_lab (label): new label of the merged labels</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        Note:</span>
<span class="sd">            Update labels in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mtype</span><span class="o">.</span><span class="n">is_valid_lab</span><span class="p">(</span><span class="n">new_lab</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_lab, </span><span class="si">{}</span><span class="s2">, must  be str or int&quot;</span><span class="p">)</span>
        <span class="n">mtype</span><span class="o">.</span><span class="n">check_is_valid_labs</span><span class="p">(</span><span class="n">orig_labs_to_merge</span><span class="p">)</span>
        <span class="c1"># all labs must be unique</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_labs_to_merge</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orig_labs_to_merge</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;orig_labs_to_merge must all be unique&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="n">orig_labs_to_merge</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ulab</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;label </span><span class="si">{}</span><span class="s2"> not in original unique &quot;</span>
                                 <span class="s2">&quot;labels&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ulab</span><span class="p">))</span>
        <span class="n">updated_labs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">orig_labs_to_merge</span><span class="p">:</span>
                <span class="n">updated_labs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_lab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span> <span class="o">=</span> <span class="n">updated_labs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_up_lab_rel_attrs</span><span class="p">()</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.relabel"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new SingleLabelClassifiedSamples with new labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SingleLabelClassifiedSamples</span><span class="p">(</span>
                   <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">labs</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                   <span class="n">sids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="n">fids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fids</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                   <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nprocs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.id_x"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.id_x">[docs]</a>    <span class="k">def</span> <span class="nf">id_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_sids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">selected_fids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subset samples by (sample IDs, feature IDs).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        selected_s_inds: int array</span>
<span class="sd">            Index array of selected samples. If is None, select all.</span>
<span class="sd">        selected_f_inds: int array</span>
<span class="sd">            Index array of selected features. If is None, select all.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset: SingleLabelClassifiedSamples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">selected_sids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_s_inds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selected_s_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_id_to_ind</span><span class="p">(</span><span class="n">selected_sids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">selected_fids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selected_f_inds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selected_f_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_id_to_ind</span><span class="p">(</span><span class="n">selected_fids</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind_x</span><span class="p">(</span><span class="n">selected_s_inds</span><span class="p">,</span> <span class="n">selected_f_inds</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.select_labs_bool_inds"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.select_labs_bool_inds">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">select_labs_bool_inds</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">selected_labs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">selected_labs</span><span class="p">):</span>
            <span class="n">selected_labs</span> <span class="o">=</span> <span class="p">[</span><span class="n">selected_labs</span><span class="p">]</span>

        <span class="n">ref_uniq_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">ref_uniq_labs</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">selected_labs</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;selected_labs: </span><span class="si">{}</span><span class="s2"> are not all existed &quot;</span>
                             <span class="s2">&quot;in the unique ref labels &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">selected_labs</span><span class="p">,</span> <span class="n">ref_uniq_labs</span><span class="p">))</span>
        <span class="n">lab_selected_s_bool_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lab_selected_s_bool_inds</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.lab_x_bool_inds"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.lab_x_bool_inds">[docs]</a>    <span class="k">def</span> <span class="nf">lab_x_bool_inds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_labs_bool_inds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.lab_x"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.lab_x">[docs]</a>    <span class="k">def</span> <span class="nf">lab_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">):</span>
        <span class="n">lab_selected_s_bool_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab_x_bool_inds</span><span class="p">(</span><span class="n">selected_labs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind_x</span><span class="p">(</span><span class="n">lab_selected_s_bool_inds</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xgb_train_runner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lab_inds</span><span class="p">,</span> <span class="n">fids</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                          <span class="n">num_boost_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xgb_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run xgboost train with prepared data and parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_fscore_list: list</span>
<span class="sd">            Ordered important features and their results.</span>
<span class="sd">        bst: xgb.Booster</span>
<span class="sd">            Fitted model.</span>
<span class="sd">        eval_stats: tuple</span>
<span class="sd">            Final test and train error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_uniq_labs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lab_inds</span><span class="p">))</span>
        <span class="c1"># xgb only takes string as feature names</span>
        <span class="n">str_fids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">fids</span><span class="p">))</span>
        <span class="n">orig_fid_lut</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">str_fids</span><span class="p">,</span> <span class="n">fids</span><span class="p">))</span>
        <span class="c1"># Prepare default xgboost parameters</span>
        <span class="n">xgb_random_state</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">random_state</span>
        <span class="k">if</span> <span class="n">xgb_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use log2(n_features) as default depth.</span>
            <span class="n">xgb_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;eta&quot;</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span>
                <span class="s2">&quot;max_depth&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
                <span class="s2">&quot;silent&quot;</span><span class="p">:</span> <span class="n">silent</span><span class="p">,</span>
                <span class="s2">&quot;nthread&quot;</span><span class="p">:</span> <span class="n">nprocs</span><span class="p">,</span>
                <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;lambda&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="n">xgb_random_state</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">n_uniq_labs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># do binary classification</span>
                <span class="n">xgb_params</span><span class="p">[</span><span class="s2">&quot;objective&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;binary:logistic&quot;</span>
                <span class="n">xgb_params</span><span class="p">[</span><span class="s2">&quot;eval_metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># do multi-label classification</span>
                <span class="n">xgb_params</span><span class="p">[</span><span class="s2">&quot;num_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_uniq_labs</span>
                <span class="n">xgb_params</span><span class="p">[</span><span class="s2">&quot;objective&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;multi:softmax&quot;</span>
                <span class="n">xgb_params</span><span class="p">[</span><span class="s2">&quot;eval_metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;merror&quot;</span>
        <span class="c1"># split training and testing</span>
        <span class="c1"># random state determined by numpy</span>
        <span class="n">train_x</span><span class="p">,</span> <span class="n">test_x</span><span class="p">,</span> <span class="n">train_labs</span><span class="p">,</span> <span class="n">test_labs</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">lab_inds</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span>
        <span class="c1"># xgb datastructure to hold data and labels</span>
        <span class="n">dtrain</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">DMatrix</span><span class="p">(</span><span class="n">train_x</span><span class="p">,</span> <span class="n">train_labs</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="n">str_fids</span><span class="p">)</span>
        <span class="n">dtest</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">DMatrix</span><span class="p">(</span><span class="n">test_x</span><span class="p">,</span> <span class="n">test_labs</span><span class="p">,</span> <span class="n">feature_names</span><span class="o">=</span><span class="n">str_fids</span><span class="p">)</span>
        <span class="c1"># list of data to evaluate</span>
        <span class="n">eval_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dtest</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">dtrain</span><span class="p">,</span> <span class="s2">&quot;train&quot;</span><span class="p">)]</span>
        <span class="n">evals_result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">silent</span><span class="p">:</span>
            <span class="n">verbose_eval</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verbose_eval</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># bst is the train boost tree model</span>
        <span class="n">bst</span> <span class="o">=</span> <span class="n">xgb</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">xgb_params</span><span class="p">,</span> <span class="n">dtrain</span><span class="p">,</span> <span class="n">num_boost_round</span><span class="p">,</span> <span class="n">eval_list</span><span class="p">,</span>
                        <span class="n">evals_result</span><span class="o">=</span><span class="n">evals_result</span><span class="p">,</span> <span class="n">verbose_eval</span><span class="o">=</span><span class="n">verbose_eval</span><span class="p">)</span>
        <span class="c1"># Turn dict to list</span>
        <span class="c1"># [ [(&#39;train...&#39;, float), ...],</span>
        <span class="c1">#   [(&#39;test...&#39;, float), ...] ]</span>
        <span class="n">eval_stats</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">eval_name</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">mname</span><span class="p">,</span>
                        <span class="n">mval_list</span><span class="p">[</span><span class="n">num_boost_round</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                       <span class="k">for</span> <span class="n">mname</span><span class="p">,</span> <span class="n">mval_list</span> <span class="ow">in</span> <span class="n">eval_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                      <span class="k">for</span> <span class="n">eval_name</span><span class="p">,</span> <span class="n">eval_dict</span> <span class="ow">in</span> <span class="n">evals_result</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="c1"># {feature_name: fscore, ...}</span>
        <span class="n">fscore_dict</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">get_fscore</span><span class="p">()</span>
        <span class="n">orig_fid_fscore_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">orig_fid_lut</span><span class="p">[</span><span class="n">istr_fid</span><span class="p">],</span> <span class="n">ifscore</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">istr_fid</span><span class="p">,</span> <span class="n">ifscore</span> <span class="ow">in</span> <span class="n">fscore_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">sorted_fscore_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">orig_fid_fscore_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sorted_fscore_list</span><span class="p">,</span> <span class="n">bst</span><span class="p">,</span> <span class="n">eval_stats</span>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.feature_importance_across_labs"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.feature_importance_across_labs">[docs]</a>    <span class="k">def</span> <span class="nf">feature_importance_across_labs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                       <span class="n">num_boost_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="n">xgb_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">num_bootstrap_round</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                       <span class="n">bootstrap_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">shuffle_features</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use xgboost to determine the importance of features determining the</span>
<span class="sd">        difference between samples with different labels.</span>

<span class="sd">        Run cross validation on dataset and obtain import features.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        selected_labs: label list</span>
<span class="sd">            Labels to compare using xgboost.</span>
<span class="sd">        test_size: float in range (0, 1)</span>
<span class="sd">            Ratio of samples to be used for testing</span>
<span class="sd">        num_bootstrap_round: int</span>
<span class="sd">            Do num_bootstrap_round times of simple bootstrapping if</span>
<span class="sd">            `num_bootstrap_round &gt; 0`.</span>
<span class="sd">        bootstrap_size: int</span>
<span class="sd">            The number of samples for each bootstrapping run.</span>
<span class="sd">        shuffle_features: bool</span>
<span class="sd">        num_boost_round: int</span>
<span class="sd">            The number of rounds for xgboost training.</span>
<span class="sd">        random_state: int</span>
<span class="sd">        nprocs: int</span>
<span class="sd">        xgb_params: dict</span>
<span class="sd">            Parameters for xgboost run. If None, default will be used. If</span>
<span class="sd">            provided, they will be directly used for xgbooster.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        feature_importance_list: list of feature importance of each run</span>
<span class="sd">            `[(feature_id, fscore), ...]`</span>
<span class="sd">        bst_list: list of xgb Booster</span>
<span class="sd">            Fitted boost tree model</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If multiple features are highly correlated, they may not all show up</span>
<span class="sd">        in the resulting tree. You could try to reduce redundant features first</span>
<span class="sd">        before comparing different clusters, or you could also interpret the</span>
<span class="sd">        important features further after obtaining the important features.</span>

<span class="sd">        For details about xgboost parameters, check the following links:</span>

<span class="sd">        [1] https://www.analyticsvidhya.com/blog/2016/03/\</span>
<span class="sd">complete-guide-parameter-tuning-xgboost-with-codes-python/</span>

<span class="sd">        [2] http://xgboost.readthedocs.io/en/latest/python/python_intro.html</span>

<span class="sd">        [3] http://xgboost.readthedocs.io/en/latest/parameter.html</span>

<span class="sd">        [4] https://xgboost.readthedocs.io/en/latest/how_to/param_tuning.html</span>

<span class="sd">        [5] https://www.analyticsvidhya.com/blog/2016/03/\</span>
<span class="sd">complete-guide-parameter-tuning-xgboost-with-codes-python/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_boost_round</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_boost_round</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_boost_round</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_boost_round must &gt;= 1&quot;</span><span class="p">)</span>
        <span class="c1"># This is for implementing caching in the future.</span>
        <span class="n">selected_uniq_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">selected_labs</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># subset SLCS</span>
        <span class="n">lab_selected_slcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab_x</span><span class="p">(</span><span class="n">selected_uniq_labs</span><span class="p">)</span>
        <span class="c1"># unique labels in SLCS after subsetting</span>
        <span class="c1"># Since lab_x checks whether selected labels are all existing,</span>
        <span class="c1"># the unique labels of the subset is equivalent to input selected</span>
        <span class="c1"># labels.</span>
        <span class="n">uniq_labs</span> <span class="o">=</span> <span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># convert labels into indices from 0 to n_classes</span>
        <span class="n">n_uniq_labs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_labs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_uniq_labs</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of unique labels should &gt; 1. &quot;</span>
                             <span class="s2">&quot;Provided uniq labs:&quot;</span>
                             <span class="s2">&quot; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uniq_labs</span><span class="p">))</span>
        <span class="n">lab_ind_lut</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">uniq_labs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_uniq_labs</span><span class="p">)))</span>
        <span class="n">lab_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">lab_ind_lut</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_labs</span><span class="p">]</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># shuffle features if necessary</span>
        <span class="n">fids</span> <span class="o">=</span> <span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">fids</span>
        <span class="k">if</span> <span class="n">shuffle_features</span><span class="p">:</span>
            <span class="n">feature_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">feature_inds</span><span class="p">,</span> <span class="n">fids</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
                <span class="n">feature_inds</span><span class="p">,</span> <span class="n">fids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_inds</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># perform bootstrapping if necessary</span>
        <span class="n">num_bootstrap_round</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_bootstrap_round</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_bootstrap_round</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># no bootstrapping</span>
            <span class="c1"># _xgb_train_runner returns (fscores, bst, eval_stats)</span>
            <span class="n">sorted_fs_list</span><span class="p">,</span> <span class="n">bst</span><span class="p">,</span> <span class="n">eval_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xgb_train_runner</span><span class="p">(</span>
                <span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_x</span><span class="p">[:,</span> <span class="n">feature_inds</span><span class="p">],</span>
                <span class="n">lab_inds</span><span class="p">,</span> <span class="n">fids</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
                <span class="n">num_boost_round</span><span class="o">=</span><span class="n">num_boost_round</span><span class="p">,</span>
                <span class="n">xgb_params</span><span class="o">=</span><span class="n">xgb_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">eval_stats</span><span class="p">)</span>
            <span class="n">bst_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">bst</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># do bootstrapping</span>
            <span class="c1"># ([dict of scores], [list of bsts], dict of eval stats)</span>
            <span class="n">fs_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">bst_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">eval_stats_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bootstrap_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bootstrap_size</span> <span class="o">=</span> <span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sample_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># bootstrapping rounds</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bootstrap_round</span><span class="p">):</span>
                <span class="c1"># random state determined by numpy</span>
                <span class="c1"># ensure all labels present</span>
                <span class="c1"># initialize resample sample_indices and labels</span>
                <span class="n">bs_s_inds</span><span class="p">,</span> <span class="n">bs_lab_inds</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                    <span class="n">sample_inds</span><span class="p">,</span> <span class="n">lab_inds</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">n_samples</span><span class="o">=</span><span class="n">bootstrap_size</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bs_lab_inds</span><span class="p">))</span> <span class="o">!=</span> <span class="n">n_uniq_labs</span><span class="p">:</span>
                    <span class="n">bs_s_inds</span><span class="p">,</span> <span class="n">bs_lab_inds</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                        <span class="n">sample_inds</span><span class="p">,</span> <span class="n">lab_inds</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">n_samples</span><span class="o">=</span><span class="n">bootstrap_size</span><span class="p">)</span>
                <span class="n">fscores</span><span class="p">,</span> <span class="n">bst</span><span class="p">,</span> <span class="n">eval_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xgb_train_runner</span><span class="p">(</span>
                    <span class="n">lab_selected_slcs</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">bs_s_inds</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">feature_inds</span><span class="p">],</span>
                    <span class="n">bs_lab_inds</span><span class="p">,</span> <span class="n">fids</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
                    <span class="n">num_boost_round</span><span class="o">=</span><span class="n">num_boost_round</span><span class="p">,</span>
                    <span class="n">xgb_params</span><span class="o">=</span><span class="n">xgb_params</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">)</span>
                <span class="c1"># Sum fscores</span>
                <span class="k">for</span> <span class="n">fid</span><span class="p">,</span> <span class="n">fs</span> <span class="ow">in</span> <span class="n">fscores</span><span class="p">:</span>
                    <span class="n">fs_dict</span><span class="p">[</span><span class="n">fid</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fs</span>
                <span class="n">bst_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bst</span><span class="p">)</span>
                <span class="c1"># est: eval stats tuple</span>
                <span class="c1"># [ [(&#39;train...&#39;, float), ...],</span>
                <span class="c1">#   [(&#39;test...&#39;, float), ...] ]</span>
                <span class="k">for</span> <span class="n">elist</span> <span class="ow">in</span> <span class="n">eval_stats</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ename</span><span class="p">,</span> <span class="n">evalue</span> <span class="ow">in</span> <span class="n">elist</span><span class="p">:</span>
                        <span class="n">eval_stats_dict</span><span class="p">[</span><span class="n">ename</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evalue</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shuffle_features</span><span class="p">:</span>
                    <span class="n">feature_inds</span><span class="p">,</span> <span class="n">fids</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
                        <span class="n">feature_inds</span><span class="p">,</span> <span class="n">fids</span><span class="p">)</span>
            <span class="c1"># average score</span>
            <span class="k">for</span> <span class="n">fid</span> <span class="ow">in</span> <span class="n">fs_dict</span><span class="p">:</span>
                <span class="n">fs_dict</span><span class="p">[</span><span class="n">fid</span><span class="p">]</span> <span class="o">/=</span> <span class="n">num_bootstrap_round</span>
            <span class="n">sorted_fs_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># calculate mean +/- std of eval stats</span>
            <span class="k">for</span> <span class="n">ename</span><span class="p">,</span> <span class="n">evalue_list</span> <span class="ow">in</span> <span class="n">eval_stats_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: mean </span><span class="si">{}</span><span class="s2">, std </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">ename</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">evalue_list</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">evalue_list</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="c1"># return same things for two branches</span>
        <span class="k">return</span> <span class="n">sorted_fs_list</span><span class="p">,</span> <span class="n">bst_list</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.feature_importance_distintuishing_labs"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.feature_importance_distintuishing_labs">[docs]</a>    <span class="k">def</span> <span class="nf">feature_importance_distintuishing_labs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_labs</span><span class="p">,</span>
                                               <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                               <span class="n">num_boost_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                               <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                               <span class="n">xgb_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">num_bootstrap_round</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                               <span class="n">bootstrap_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">shuffle_features</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use xgboost to compare selected labels and others.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selected_s_bool_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab_x_bool_inds</span><span class="p">(</span><span class="n">selected_labs</span><span class="p">)</span>
        <span class="c1"># binary labs distinguishing selected and non-selected</span>
        <span class="n">io_bin_lab_arr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;selected&quot;</span> <span class="k">if</span> <span class="n">s</span> <span class="k">else</span> <span class="s2">&quot;non-selected&quot;</span>
                          <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selected_s_bool_inds</span><span class="p">]</span>
        <span class="c1"># create a new SLCS instance with new labels</span>
        <span class="n">nl_slcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">io_bin_lab_arr</span><span class="p">)</span>
        <span class="n">fi_res</span> <span class="o">=</span> <span class="n">nl_slcs</span><span class="o">.</span><span class="n">feature_importance_across_labs</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;selected&quot;</span><span class="p">,</span> <span class="s2">&quot;non-selected&quot;</span><span class="p">],</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
            <span class="n">num_boost_round</span><span class="o">=</span><span class="n">num_boost_round</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
            <span class="n">xgb_params</span><span class="o">=</span><span class="n">xgb_params</span><span class="p">,</span> <span class="n">num_bootstrap_round</span><span class="o">=</span><span class="n">num_bootstrap_round</span><span class="p">,</span>
            <span class="n">bootstrap_size</span><span class="o">=</span><span class="n">bootstrap_size</span><span class="p">,</span> <span class="n">shuffle_features</span><span class="o">=</span><span class="n">shuffle_features</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fi_res</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.feature_importance_each_lab"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.feature_importance_each_lab">[docs]</a>    <span class="k">def</span> <span class="nf">feature_importance_each_lab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">num_boost_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                    <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">xgb_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_bootstrap_round</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">bootstrap_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">shuffle_features</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use xgboost to compare each label with others. Experimental.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct important feature lut</span>
        <span class="c1"># {ulab0: [if1, if2, ...], ...}</span>
        <span class="n">ulab_fi_lut</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="p">:</span>
            <span class="c1"># get bool indices of current label</span>
            <span class="n">ulab_s_bool_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab_x_bool_inds</span><span class="p">(</span><span class="n">ulab</span><span class="p">)</span>
            <span class="c1"># compare current label with other samples</span>
            <span class="n">fi_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_importance_distintuishing_labs</span><span class="p">(</span>
                <span class="n">ulab</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
                <span class="n">num_boost_round</span><span class="o">=</span><span class="n">num_boost_round</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
                <span class="n">xgb_params</span><span class="o">=</span><span class="n">xgb_params</span><span class="p">,</span>
                <span class="n">num_bootstrap_round</span><span class="o">=</span><span class="n">num_bootstrap_round</span><span class="p">,</span>
                <span class="n">bootstrap_size</span><span class="o">=</span><span class="n">bootstrap_size</span><span class="p">,</span>
                <span class="n">shuffle_features</span><span class="o">=</span><span class="n">shuffle_features</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ffs</span> <span class="ow">in</span> <span class="n">fi_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_id_x_vec</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
                <span class="c1"># current label values</span>
                <span class="n">ulab_x</span> <span class="o">=</span> <span class="n">fx</span><span class="p">[</span><span class="n">ulab_s_bool_inds</span><span class="p">]</span>
                <span class="c1"># other values</span>
                <span class="n">other_x</span> <span class="o">=</span> <span class="n">fx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ulab_s_bool_inds</span><span class="p">)]</span>
                <span class="c1"># current lab mean</span>
                <span class="n">ulab_x_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ulab_x</span><span class="p">)</span>
                <span class="c1"># other mean</span>
                <span class="n">other_x_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">other_x</span><span class="p">)</span>
                <span class="c1"># mean fold change</span>
                <span class="n">ulab_mfc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulab_x_mean</span> <span class="o">-</span> <span class="n">other_x_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">ulab_x_mean</span>
                <span class="c1"># ks test result</span>
                <span class="n">ks_res</span> <span class="o">=</span> <span class="n">ks_2samp</span><span class="p">(</span><span class="n">ulab_x</span><span class="p">,</span> <span class="n">other_x</span><span class="p">)</span>
                <span class="n">ulab_fi_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fid</span><span class="p">,</span> <span class="n">ulab_mfc</span><span class="p">,</span> <span class="n">ks_res</span><span class="o">.</span><span class="n">pvalue</span><span class="p">))</span>
            <span class="n">ulab_fi_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ulab_fi_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ulab_fi_lut</span><span class="p">[</span><span class="n">ulab</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">ulab_fi_lut</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.tsne_plot"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.tsne_plot">[docs]</a>    <span class="k">def</span> <span class="nf">tsne_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gradient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">selected_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">shuffle_label_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">add_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">n_txt_per_cluster</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                  <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the last t-SNE projection with the provided gradient as color.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labs</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SingleLabelClassifiedSamples</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tsne_plot</span><span class="p">(</span>
                        <span class="n">gradient</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                        <span class="n">selected_labels</span><span class="o">=</span><span class="n">selected_labels</span><span class="p">,</span>
                        <span class="n">shuffle_label_colors</span><span class="o">=</span><span class="n">shuffle_label_colors</span><span class="p">,</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="n">xlab</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="n">ylab</span><span class="p">,</span>
                        <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                        <span class="n">add_legend</span><span class="o">=</span><span class="n">add_legend</span><span class="p">,</span>
                        <span class="n">n_txt_per_cluster</span><span class="o">=</span><span class="n">n_txt_per_cluster</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.tsne_feature_gradient_plot"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.tsne_feature_gradient_plot">[docs]</a>    <span class="k">def</span> <span class="nf">tsne_feature_gradient_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">selected_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">shuffle_label_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">add_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">n_txt_per_cluster</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                   <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the last t-SNE projection with the provided gradient as color.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fid: feature id scalar</span>
<span class="sd">            ID of the feature to be used for gradient plot.</span>
<span class="sd">        transform: callable</span>
<span class="sd">            Map transform on feature before plotting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labs</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SingleLabelClassifiedSamples</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tsne_feature_gradient_plot</span><span class="p">(</span>
                        <span class="n">fid</span><span class="o">=</span><span class="n">fid</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                        <span class="n">selected_labels</span><span class="o">=</span><span class="n">selected_labels</span><span class="p">,</span>
                        <span class="n">shuffle_label_colors</span><span class="o">=</span><span class="n">shuffle_label_colors</span><span class="p">,</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="n">xlab</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="n">ylab</span><span class="p">,</span>
                        <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span>
                        <span class="n">add_legend</span><span class="o">=</span><span class="n">add_legend</span><span class="p">,</span>
                        <span class="n">n_txt_per_cluster</span><span class="o">=</span><span class="n">n_txt_per_cluster</span><span class="p">,</span>
                        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.feature_swarm_plot"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.feature_swarm_plot">[docs]</a>    <span class="k">def</span> <span class="nf">feature_swarm_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">selected_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
        <span class="n">f_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_id_to_ind</span><span class="p">([</span><span class="n">fid</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_ind_x_vec</span><span class="p">(</span><span class="n">f_ind</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">transform</span><span class="p">):</span>
                <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">fx</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transform must be a callable&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;labels (</span><span class="si">{}</span><span class="s2">) must have same length as &quot;</span>
                             <span class="s2">&quot;n_samples.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labs</span>

        <span class="k">return</span> <span class="n">swarm</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">selected_labels</span><span class="o">=</span><span class="n">selected_labels</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="n">xlab</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="n">ylab</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.dmat_heatmap"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.dmat_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">dmat_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot distance matrix with rows colored by current labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selected_s_bool_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab_x_bool_inds</span><span class="p">(</span><span class="n">selected_labels</span><span class="p">)</span>
        <span class="n">selected_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">[</span><span class="n">selected_s_bool_inds</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">selected_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">selected_s_bool_inds</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">selected_s_bool_inds</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">heatmap</span><span class="p">(</span><span class="n">selected_d</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">selected_labels</span><span class="p">,</span>
                       <span class="n">col_labels</span><span class="o">=</span><span class="n">col_labels</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="n">xlab</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="n">ylab</span><span class="p">,</span>
                       <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SingleLabelClassifiedSamples.xmat_heatmap"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.xmat_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">xmat_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selected_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">selected_fids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">col_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot x as heatmap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">selected_s_bool_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lab_x_bool_inds</span><span class="p">(</span><span class="n">selected_labels</span><span class="p">)</span>
        <span class="n">selected_s_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="p">[</span><span class="n">selected_s_bool_inds</span><span class="p">]</span>
        <span class="n">selected_slcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id_x</span><span class="p">(</span><span class="n">selected_s_ids</span><span class="p">,</span> <span class="n">selected_fids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">heatmap</span><span class="p">(</span><span class="n">selected_slcs</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">selected_slcs</span><span class="o">.</span><span class="n">labs</span><span class="p">,</span>
                       <span class="n">col_labels</span><span class="o">=</span><span class="n">col_labels</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">xlab</span><span class="o">=</span><span class="n">xlab</span><span class="p">,</span> <span class="n">ylab</span><span class="o">=</span><span class="n">ylab</span><span class="p">,</span>
                       <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Sort the clustered sample_ids with the reference order of another.</span>
    <span class="c1">#</span>
    <span class="c1"># Sort sids according to labs</span>
    <span class="c1"># If ref_sid_order is not None:</span>
    <span class="c1">#   sort sids further according to ref_sid_order</span>
<div class="viewcode-block" id="SingleLabelClassifiedSamples.lab_sorted_sids"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.lab_sorted_sids">[docs]</a>    <span class="k">def</span> <span class="nf">lab_sorted_sids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_sid_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">sep_lab_sid_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sep_lab_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iter_lab</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sid_lut</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">iter_sid_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sid_lut</span><span class="p">[</span><span class="n">iter_lab</span><span class="p">]</span>
            <span class="n">sep_lab_sid_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_sid_arr</span><span class="p">)</span>
            <span class="n">sep_lab_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">iter_lab</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">iter_sid_arr</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">ref_sid_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mtype</span><span class="o">.</span><span class="n">check_is_valid_sfids</span><span class="p">(</span><span class="n">ref_sid_order</span><span class="p">)</span>
            <span class="n">ref_sid_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_sid_order</span><span class="p">)</span>
            <span class="c1"># sort r according to q</span>
            <span class="c1"># assumes:</span>
            <span class="c1"># - r contains all elements in q</span>
            <span class="c1"># - r is 1d np array</span>

            <span class="k">def</span> <span class="nf">sort_flat_sids</span><span class="p">(</span><span class="n">query_sids</span><span class="p">,</span> <span class="n">ref_sids</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ref_sids</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ref_sids</span><span class="p">,</span> <span class="n">query_sids</span><span class="p">)]</span>

            <span class="c1"># sort inner sid list but maintains the order as sep_lab_list</span>
            <span class="n">sep_lab_sid_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_flat_sids</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ref_sid_order</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sep_lab_sid_list</span><span class="p">]</span>
            <span class="n">sep_lab_min_sid_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sep_lab_sid_list</span><span class="p">]</span>
            <span class="n">sorted_sep_lab_min_sid_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">sort_flat_sids</span><span class="p">(</span><span class="n">sep_lab_min_sid_list</span><span class="p">,</span> <span class="n">ref_sid_order</span><span class="p">))</span>
            <span class="n">min_sid_sorted_sep_lab_ind_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">sep_lab_min_sid_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sorted_sep_lab_min_sid_list</span>
            <span class="p">]</span>
            <span class="n">sep_lab_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sep_lab_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">min_sid_sorted_sep_lab_ind_list</span><span class="p">]</span>
            <span class="n">sep_lab_sid_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sep_lab_sid_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">min_sid_sorted_sep_lab_ind_list</span><span class="p">]</span>

        <span class="n">lab_sorted_sid_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">sep_lab_sid_list</span><span class="p">)</span>
        <span class="n">lab_sorted_lab_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">sep_lab_list</span><span class="p">)</span>

        <span class="c1"># check sorted sids are the same set as original</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">lab_sorted_sid_arr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="p">))</span>
        <span class="c1"># check sorted labs are the same set as original</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">lab_sorted_lab_arr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">))</span>
        <span class="c1"># check sorted (sid, lab) matchings are the same set as original</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span>
            <span class="n">lab_sorted_lab_arr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lab_sorted_sid_arr</span><span class="p">)],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sids</span><span class="p">)])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">lab_sorted_sid_arr</span><span class="p">,</span> <span class="n">lab_sorted_lab_arr</span><span class="p">)</span></div>

    <span class="c1"># See how two clustering criteria match with each other.</span>
    <span class="c1"># When given q_slc_samples is not None, sids and labs are ignored.</span>
    <span class="c1"># When q_slc_samples is None, sids and labs must be provided</span>
<div class="viewcode-block" id="SingleLabelClassifiedSamples.cross_labs"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.SingleLabelClassifiedSamples.cross_labs">[docs]</a>    <span class="k">def</span> <span class="nf">cross_labs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_slc_samples</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_slc_samples</span><span class="p">,</span> <span class="n">SingleLabelClassifiedSamples</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Query should be an instance of &quot;</span>
                            <span class="s2">&quot;SingleLabelClassifiedSamples&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ref_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_lab_lut</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q_slc_samples</span><span class="o">.</span><span class="n">sids</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;query sid </span><span class="si">{}</span><span class="s2"> is not in ref sids.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>

        <span class="n">query_labs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q_slc_samples</span><span class="o">.</span><span class="n">labs</span><span class="p">)</span>

        <span class="n">uniq_rlabs</span><span class="p">,</span> <span class="n">uniq_rlab_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cross_lab_lut</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniq_rlabs</span><span class="p">)):</span>
            <span class="c1"># ref cluster i. query unique labs.</span>
            <span class="n">ref_ci_quniq</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">query_labs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">)</span> <span class="o">==</span> <span class="n">uniq_rlabs</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span>
                <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
            <span class="n">cross_lab_lut</span><span class="p">[</span><span class="n">uniq_rlabs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uniq_rlab_cnts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                            <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">ref_ci_quniq</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">cross_lab_lut</span></div></div>


<span class="c1"># TODO: rename MDLSingleLabelClassifiedSamples as</span>
<span class="c1"># MdlSingleLabelClassifiedSamples</span>
<div class="viewcode-block" id="MDLSingleLabelClassifiedSamples"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.MDLSingleLabelClassifiedSamples">[docs]</a><span class="k">class</span> <span class="nc">MDLSingleLabelClassifiedSamples</span><span class="p">(</span><span class="n">SingleLabelClassifiedSamples</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MDLSingleLabelClassifiedSamples inherits SingleLabelClassifiedSamples to</span>
<span class="sd">    offer MDL operations.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (2d number array): data matrix</span>
<span class="sd">        labs (list of str or int): labels</span>
<span class="sd">        sids (list of str or int): sample ids</span>
<span class="sd">        fids (list of str or int): feature ids</span>
<span class="sd">        encode_type (&quot;auto&quot;, &quot;data&quot;, or &quot;distance&quot;): Type of values to encode.</span>
<span class="sd">            If &quot;auto&quot;, encode data when n_features &lt;= 100.</span>
<span class="sd">        mdl_method (mdl.Mdl): If None, use ZeroIGKdeMdl for encoded values</span>
<span class="sd">            with &gt;= 50% zeros, and use GKdeMdl otherwise.</span>
<span class="sd">        d (2d number array): distance matrix</span>
<span class="sd">        metric (str): distance metric for scipy</span>
<span class="sd">        nprocs (int)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _mdl_method (.mdl.Mdl)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LabMdlResult</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;LabMdlResult&quot;</span><span class="p">,</span>
                              <span class="p">[</span><span class="s2">&quot;ulab_mdl_sum&quot;</span><span class="p">,</span> <span class="s2">&quot;ulab_s_inds&quot;</span><span class="p">,</span> <span class="s2">&quot;ulab_cnts&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;ulab_mdls&quot;</span><span class="p">,</span> <span class="s2">&quot;cluster_mdl&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">labs</span><span class="p">,</span> <span class="n">sids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">encode_type</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">mdl_method</span><span class="o">=</span><span class="n">mdl</span><span class="o">.</span><span class="n">ZeroIGKdeMdl</span><span class="p">,</span>
                 <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;correlation&quot;</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MDLSingleLabelClassifiedSamples</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">labs</span><span class="o">=</span><span class="n">labs</span><span class="p">,</span> <span class="n">sids</span><span class="o">=</span><span class="n">sids</span><span class="p">,</span> <span class="n">fids</span><span class="o">=</span><span class="n">fids</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
            <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>
        <span class="c1"># initialize encode type</span>
        <span class="k">if</span> <span class="n">encode_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;distance&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;encode_type must in &quot;</span>
                             <span class="s2">&quot;(&#39;auto&#39;, &#39;data&#39;, &#39;distance&#39;).&quot;</span>
                             <span class="s2">&quot;Provided: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">encode_type</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">encode_type</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="n">encode_type</span> <span class="o">=</span> <span class="s2">&quot;distance&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">encode_type</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">=</span> <span class="n">encode_type</span>
        <span class="c1"># initialize mdl method</span>
        <span class="k">if</span> <span class="n">mdl_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">encode_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>
            <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># empty matrix</span>
                <span class="n">mdl_method</span> <span class="o">=</span> <span class="n">mdl</span><span class="o">.</span><span class="n">GKdeMdl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_nonzero</span> <span class="o">/</span> <span class="n">ex</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">mdl_method</span> <span class="o">=</span> <span class="n">mdl</span><span class="o">.</span><span class="n">GKdeMdl</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mdl_method</span> <span class="o">=</span> <span class="n">mdl</span><span class="o">.</span><span class="n">ZeroIGKdeMdl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mdl_method</span> <span class="o">=</span> <span class="n">mdl_method</span>

<div class="viewcode-block" id="MDLSingleLabelClassifiedSamples.per_col_encoders"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.MDLSingleLabelClassifiedSamples.per_col_encoders">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">per_col_encoders</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">encode_type</span><span class="p">,</span> <span class="n">mdl_method</span><span class="o">=</span><span class="n">mdl</span><span class="o">.</span><span class="n">ZeroIGKdeMdl</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute mdl encoder for each column</span>

<span class="sd">        Args:</span>
<span class="sd">            x (2d number array)</span>
<span class="sd">            encode_type (&quot;data&quot; or &quot;distance&quot;)</span>
<span class="sd">            mdl_method (mdl.Mdl)</span>
<span class="sd">            nprocs (int)</span>
<span class="sd">            verbose (bool)</span>

<span class="sd">        Returns:</span>
<span class="sd">            :obj: list of column mdl encoders of x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verbose is not implemented</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">mdl_method</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be a subclass of eda.mdl.Mdl&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">mdl_method</span><span class="p">,</span> <span class="n">mdl</span><span class="o">.</span><span class="n">Mdl</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be a subclass of eda.mdl.Mdl&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x should be 2D. x.shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="n">nprocs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nprocs</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encode_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
            <span class="n">col_encoders</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parmap</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x1d</span><span class="p">:</span> <span class="n">mdl_method</span><span class="p">(</span><span class="n">x1d</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">encode_type</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="c1"># distance</span>
            <span class="n">s_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">def</span> <span class="nf">single_s_mdl_encoder</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="c1"># copy indices for parallel processing</span>
                <span class="n">i_s_ind</span> <span class="o">=</span> <span class="n">s_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">non_i_s_inds</span> <span class="o">=</span> <span class="n">s_inds</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_inds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">return</span> <span class="n">mdl_method</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i_s_ind</span><span class="p">,</span> <span class="n">non_i_s_inds</span><span class="p">])</span>

            <span class="n">col_encoders</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parmap</span><span class="p">(</span><span class="n">single_s_mdl_encoder</span><span class="p">,</span> <span class="n">s_inds</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;unknown encode_type: &quot;</span>
                                      <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">encode_type</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">col_encoders</span></div>

<div class="viewcode-block" id="MDLSingleLabelClassifiedSamples.no_lab_mdl"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.MDLSingleLabelClassifiedSamples.no_lab_mdl">[docs]</a>    <span class="k">def</span> <span class="nf">no_lab_mdl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute mdl of each feature without separating samples by labels</span>

<span class="sd">        Args:</span>
<span class="sd">            nprocs (int)</span>
<span class="sd">            verbose (bool): Not implemented</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: mdl of matrix without separating samples by labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: implement verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
            <span class="n">col_encoders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_col_encoders</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_mdl_method</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">,</span>
                                                 <span class="n">verbose</span><span class="p">)</span>
            <span class="n">col_mdl_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">mdl</span><span class="p">,</span> <span class="n">col_encoders</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="n">col_encoders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_col_encoders</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_mdl_method</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">,</span>
                                                 <span class="n">verbose</span><span class="p">)</span>
            <span class="n">col_mdl_sum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ulab_s_ind_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span> <span class="o">==</span> <span class="n">ulab</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                               <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s_inds</span> <span class="ow">in</span> <span class="n">ulab_s_ind_list</span><span class="p">:</span>
                <span class="n">n_s_inds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_inds</span><span class="p">)</span>
                <span class="n">rn_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_s_inds</span><span class="p">))</span>
                <span class="c1"># [(encoder, x), ...]</span>
                <span class="n">enc_x_tups</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rn_inds</span><span class="p">:</span>
                    <span class="n">i_s_ind</span> <span class="o">=</span> <span class="n">s_inds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">non_i_s_inds</span> <span class="o">=</span> <span class="n">s_inds</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s_inds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">enc_x_tups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">col_encoders</span><span class="p">[</span><span class="n">i_s_ind</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">non_i_s_inds</span><span class="p">,</span> <span class="n">i_s_ind</span><span class="p">]))</span>
                <span class="n">mdls</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ext</span><span class="p">:</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                    <span class="n">enc_x_tups</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">)</span>
                <span class="n">col_mdl_sum</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mdls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Do not change encode_type after init. &quot;</span>
                                      <span class="s2">&quot;Unknown encode type &quot;</span>
                                      <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">col_mdl_sum</span></div>

<div class="viewcode-block" id="MDLSingleLabelClassifiedSamples.compute_cluster_mdl"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.MDLSingleLabelClassifiedSamples.compute_cluster_mdl">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_cluster_mdl</span><span class="p">(</span><span class="n">labs</span><span class="p">,</span> <span class="n">cl_mdl_scale_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Additional MDL for encoding the cluster</span>

<span class="sd">        - labels are encoded by multinomial distribution</span>
<span class="sd">        - parameters are encoded by 32bit float</span>
<span class="sd">          np.log(2**32) = 22.18070977791825</span>
<span class="sd">        - scaled by factor</span>

<span class="sd">        TODO: formalize parameter mdl</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uniq_labs</span><span class="p">,</span> <span class="n">uniq_lab_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labs</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_uniq_labs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_lab_cnts</span><span class="p">)</span>
        <span class="c1"># make a flat list of labels</span>
        <span class="n">int_labs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">uniq_lab_cnts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_uniq_labs</span><span class="p">)]))</span>
        <span class="n">mn_mdl</span> <span class="o">=</span> <span class="n">mdl</span><span class="o">.</span><span class="n">MultinomialMdl</span><span class="p">(</span><span class="n">int_labs</span><span class="p">)</span><span class="o">.</span><span class="n">mdl</span>
        <span class="n">param_mdl</span> <span class="o">=</span> <span class="mf">22.18070977791825</span> <span class="o">*</span> <span class="n">n_uniq_labs</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mn_mdl</span> <span class="o">+</span> <span class="n">param_mdl</span><span class="p">)</span> <span class="o">*</span> <span class="n">cl_mdl_scale_factor</span></div>

<div class="viewcode-block" id="MDLSingleLabelClassifiedSamples.lab_mdl"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.MDLSingleLabelClassifiedSamples.lab_mdl">[docs]</a>    <span class="k">def</span> <span class="nf">lab_mdl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cl_mdl_scale_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">ret_internal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute mdl of each feature after separating samples by labels</span>

<span class="sd">        Args:</span>
<span class="sd">            cl_mdl_scale_factor (float): multiplies cluster related mdl by this</span>
<span class="sd">                number</span>
<span class="sd">            nprocs (int)</span>
<span class="sd">            verbose (bool): Not implemented</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: mdl of matrix after separating sampels by labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute cluster label overhead mdl</span>
        <span class="n">cluster_mdl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_cluster_mdl</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_labs</span><span class="p">,</span> <span class="n">cl_mdl_scale_factor</span><span class="o">=</span><span class="n">cl_mdl_scale_factor</span><span class="p">)</span>
        <span class="c1"># compute mdl for data points</span>
        <span class="n">n_uniq_labs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ulab_s_ind_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labs</span> <span class="o">==</span> <span class="n">ulab</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                           <span class="k">for</span> <span class="n">ulab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_labs</span><span class="p">]</span>
        <span class="c1"># summarize mdls of all clusters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="n">ulab_mdls</span> <span class="o">=</span> <span class="p">[</span><span class="n">MDLSingleLabelClassifiedSamples</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">s_inds</span><span class="p">],</span> <span class="n">labs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s_inds</span><span class="p">),</span>
                            <span class="n">encode_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">,</span>
                            <span class="n">mdl_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mdl_method</span><span class="p">,</span>
                            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_d</span><span class="p">[</span><span class="n">s_inds</span><span class="p">][:,</span> <span class="n">s_inds</span><span class="p">],</span>
                            <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span>
                            <span class="n">nprocs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nprocs</span><span class="p">)</span><span class="o">.</span><span class="n">no_lab_mdl</span><span class="p">()</span>
                         <span class="k">for</span> <span class="n">s_inds</span> <span class="ow">in</span> <span class="n">ulab_s_ind_list</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
            <span class="c1"># do not pass d</span>
            <span class="n">ulab_mdls</span> <span class="o">=</span> <span class="p">[</span><span class="n">MDLSingleLabelClassifiedSamples</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="n">s_inds</span><span class="p">],</span> <span class="n">labs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s_inds</span><span class="p">),</span>
                            <span class="n">encode_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">,</span>
                            <span class="n">mdl_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mdl_method</span><span class="p">,</span>
                            <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metric</span><span class="p">,</span>
                            <span class="n">nprocs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nprocs</span><span class="p">)</span><span class="o">.</span><span class="n">no_lab_mdl</span><span class="p">()</span>
                         <span class="k">for</span> <span class="n">s_inds</span> <span class="ow">in</span> <span class="n">ulab_s_ind_list</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Do not change encode_type after init. &quot;</span>
                                      <span class="s2">&quot;Unknown encode type &quot;</span>
                                      <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">))</span>
        <span class="c1"># add cluster overhead mdl to each cluster</span>
        <span class="n">ulab_cnt_ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_lab_cnts</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ulab_cl_mdls</span> <span class="o">=</span> <span class="p">[</span><span class="n">ulab_mdls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cluster_mdl</span> <span class="o">*</span> <span class="n">ulab_cnt_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_uniq_labs</span><span class="p">)]</span>
        <span class="n">ulab_mdl_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ulab_cl_mdls</span><span class="p">)</span>
        <span class="n">lab_mdl_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LabMdlResult</span><span class="p">(</span><span class="n">ulab_mdl_sum</span><span class="p">,</span> <span class="n">ulab_s_ind_list</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_uniq_lab_cnts</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                                        <span class="n">ulab_cl_mdls</span><span class="p">,</span> <span class="n">cluster_mdl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_internal</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lab_mdl_res</span><span class="p">,</span> <span class="n">ulab_mdls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lab_mdl_res</span></div>

<div class="viewcode-block" id="MDLSingleLabelClassifiedSamples.encode"><a class="viewcode-back" href="../../../scedar.eda.html#scedar.eda.slcs.MDLSingleLabelClassifiedSamples.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qx</span><span class="p">,</span> <span class="n">col_summary_func</span><span class="o">=</span><span class="nb">sum</span><span class="p">,</span>
               <span class="n">non_zero_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode input array qx with fitted code without label</span>

<span class="sd">        Args:</span>
<span class="sd">            qx (2d np number array)</span>
<span class="sd">            col_summary_func (callable): function applied on column mdls</span>
<span class="sd">            non_zero_only (bool): whether to encode non-zero entries only</span>
<span class="sd">            nprocs (int)</span>
<span class="sd">            verbose (bool)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: mdl for encoding qx</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">col_summary_func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;col_summary_func must be callable&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">==</span> <span class="s2">&quot;data&quot;</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Do not change encode_type after init. &quot;</span>
                                      <span class="s2">&quot;Unknown encode type &quot;</span>
                                      <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">qx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">qx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array to encode should have the same number of&quot;</span>
                             <span class="s2">&quot;columns as the encoded x&quot;</span><span class="p">)</span>

        <span class="n">col_encoders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_col_encoders</span><span class="p">(</span>
            <span class="n">ex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdl_method</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="n">ncols</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">q_x_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">x_col</span> <span class="o">=</span> <span class="n">qx</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># mdl_method is valid after running per_col_encoders</span>
            <span class="k">if</span> <span class="n">non_zero_only</span><span class="p">:</span>
                <span class="n">q_x_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_col</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x_col</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># all mdl methods here are valid</span>
                <span class="c1"># this branch is GKdeMdl</span>
                <span class="n">q_x_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_col</span><span class="p">)</span>
        <span class="c1"># (mdl, qx) tuple</span>
        <span class="n">mdl_qxcol_tups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">col_encoders</span><span class="p">,</span> <span class="n">q_x_cols</span><span class="p">))</span>

        <span class="n">encode_q_col_mdls</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">parmap</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ext</span><span class="p">:</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">mdl_qxcol_tups</span><span class="p">,</span> <span class="n">nprocs</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>

        <span class="n">encode_x_mdl</span> <span class="o">=</span> <span class="n">col_summary_func</span><span class="p">(</span><span class="n">encode_q_col_mdls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">encode_x_mdl</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Yuanchao Zhang.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>